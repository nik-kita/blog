<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Schema;
use App\Models\Tag;
use App\Models\Post;

class SomeDefaulPosts extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        $posts = [
            "Магия вне Ларавела запрещена?" => [<<<post
## Насколько Ларавел волшебен?
Вот эти все прикольчики со строками, когда таблицы сами получают имена, аксессоры сами знают к каким полям обращаться...
безусловно это всё очень круто! НО! Только если ты шаришь. Понятно, что я учусь для того чтобы хорошо шарить и поэтому
должен знать все эти заклинания, и конечно всё с практикой, однако, если не сложно, в комменте под этим постом, опиши самые
маст хэв договорённости, правила...
P.S.
я например так и не понял как мне роуты называть
>  по-змеиному
>  по-верблюжьи
>  с кебабом
>  или как учил старик Паскаль
post,[8, 9, 10, 11]],
         "Eloquent" => [<<<post
__Eloquent__
* Это одно и тоже что и Ларавел коллекция?
* Как, если я обращаюсь к атрибуту, то получаю нужное? Ведь если смотреть с помощью функции **dd(Eloquent)**, то можно заметить,
что эти атрибуты сами по сути являются одним из атрибутов модели. Как я сразу попадаю на нужный уровень вложенности?
post, [5, 8]],
            "Request----->>>>>" =>[ <<<post
### Как лучше пользоваться *Request(ом)*?
Есть же много вариантов как получить одно и тоже свойство из реквеста. Какие способы считаются бест практисом?
Вот я например получал айдишник поста:
```&postId = &request->input('postid');```
Но как-то глаз режет.
post, [9,8,7,4,2]],
            "Реальная проблема!!!" => [<<<post
# Как обрабатывать **like** функционал без отправки формы???
У меня под постом есть кнопочка для лайка. Также отображается текущее количесво.
Я щас не спрашиваю об настройке отношений между таблицами юзера поста...
Вопрос именно как инкрементировать это поле в посте, не делая каких-нибудь телодвижений типа отправки формы.
Вот мои варианты псевдокода. Но даже из не знаю как сделать.
1. Куда бы не пошел пользователь с этой страницы - прочесть лайки и занести в таблицу
    * Ну проблема в оптимизации. Прописывать для каждого варианта покидания страницы дополнительную фичу -- глупо
    * Если даже как-то это реализовать, то данные о лайках будут утеряны, если я как-то _грубо_ покину страницу
2. Ну это походу фантастика))) но чтоб при javascriptovom изменении количества лайков, js отправлял команду в blade к модели
    * Ну почти уверен, что это бред, просто мы же можем через json получитьь данные из blade для javascripta
    * Кстати на stackjoverflow были вопросы направления __blade--->js__, но вот как я тут насочинял: __js--->blade--->orm___)))))
3. Это как-то сделать через api роутинг...
    * хз вобще...глупость щас сказал, или норм, сойдёт
4. Есть подозрение, что люди с руками из плеч, такие штуки делают чераз Jjaks запросы
    * но не на практике не знаю, что это и как пишется название
post, [1,2,3]],
            "Components" =>[ <<<post
Я запилял со старта компоненту для хедера, сайдбара, футера...
И понял чт этотупенько как-то вышло.
Вот потом я делал компоненту для Коммента -- это прикольно и удобно вышло.
#### Вывод
Это штуки как переменные. Лучше не делать их слишком громозкими. И даже если делать, то понимать, что их структура должна буть
неизменной. Такие себе кирпичики.
**И не вставлятьь их как я в наследуемые шаблоны, а то они получаются неизменными и теряют свой первозданный смысл**
post, [6,9]],
            "Как заполнить бд конкретными данными со старта" => [<<<post
### Мой велосипед
Мне например надо было, чтоб только такие таги были в базе. Ну я и создал отдельную миграцию для этого.
Может есть чтото почеловечньее для таких целей?
post, [2,3,10]],
       "Разбор функционала этого блога" =>[ <<<post
#### Что мы умеем:
* Если человек не залогинился, то перекидывать на страницу с предложением сделать это, всякий раз, когда он лезет куда
его не просят
    * И о чудо! Там есть кнопочка **Back**! Она вернёт его откуда бы он не пришёл... ну или вернёт на домашнюю страницу, если он непонятно откуда
* А так незалогиненный пользователь может смотреть посты искать... ну об этом отдельно
* Искать посты
    * Если ввести слово в строку поиска, то доступны два режима: _искать в заголовках только_ или _совпадения в тексте тоже_
    * Random кнопочка выкидавает... короче понятно
    * Плюч под каждым постом есть теги. При клике по тегу выведутся все посты с таким тегом
* All posts посмотреть все посты
    * Каждый результат - это ссылка на просмотр этого поста
* Home тоже понятно
>
### Теперь о возможностях залогиненного юзера
* Может создать пост
* Удалить
* Редактировать
* **Комментировать**
* Если пост имеет комменты, то их можно открыть или спрятать
## Проблема
Есть кнопка для лайка. Она или увеличивает на один ли  возвращает исходное значени... но это просто js на фронте
К сожалению она никак не проработана на бэке(((
post, [1,2,4]],
            "ХООЧУ РАЗОБРАТЬСЯ" =>[ <<<post
# {{ ... }}
## VS
# {!! ... !!}

#### В ч'м разница?
Интуитивно понимаю, но хотелось бі четкости.
post, []],
        ];

        foreach($posts as $i=>$v) {
            $post = new Post;
            $post->user_id = 1;
            $post->title = $i;
            $post->body = $v[0];
            $post->save();
            $post->tags()->attach($v[1]);
        }
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::table('posts', function (Blueprint $table) {
            //
        });
    }
}
